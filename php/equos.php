<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\BadSymbol;
use \ccxt\OrderNotFound;

class equos extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'equos',
            'name' => 'Equos',
            'countries' => ['US', 'SG'],
            'rateLimit' => 10,
            'certified' => false,
            'has' => array(
                'CORS' => false,
                'fetchMarkets' => true,
                'fetchCurrencies' => true,
                'fetchTradingLimits' => false,
                'fetchTradingFees' => true,
                'fetchFundingLimits' => false,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchOrderBook' => true,
                'fetchTrades' => true,
                'fetchOHLCV' => true,
                'fetchBalance' => true,
                'fetchAccounts' => false,
                'createOrder' => true,
                'cancelOrder' => true,
                'editOrder' => false,
                'fetchOrder' => true,
                'fetchOrders' => true,
                'fetchAllOrders' => true,
                'fetchOpenOrders' => true,
                'fetchClosedOrders' => true,
                'fetchCancelledOrders' => true,
                'fetchMyTrades' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchWithdrawals' => true,
                'fetchTransactions' => true,
                'withdraw' => true,
                'fetchLedger' => true,
            ),
            'timeframes' => array(
                '1m' => 1,
                '5m' => 2,
                '15m' => 3,
                '1h' => 4,
                '6h' => 5,
                '1d' => 6,
                '7d' => 7,
            ),
            'urls' => array(
                'logo' => 'https://equos.io/assets/img/logo.svg',
                'api' => array(
                    'public' => 'https://equos.io/api/',
                    'private' => 'https://equos.io/api/',
                ),
                'test' => array(
                    'public' => 'https://testnet.equos.io/api/',
                    'private' => 'https://testnet.equos.io/api/',
                ),
                'www' => 'https://equos.io/',
                'doc' => array(
                    'https://developer.equos.io/',
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'getInstrumentPairs',
                        'getInstruments',
                        'getChart',
                        'getOrderBook',
                        'getTradeHistory',
                        'getExchangeInfo',
                    ),
                ),
                'private' => array(
                    'post' => array(
                        'getPositions',
                        'order',
                        'getOrderStatus',
                        'getOrders',
                        'cancelOrder',
                        'cancelReplaceOrder',
                        'getDepositAddresses',
                        'getDepositHistory',
                        'getWithdrawRequests',
                        'sendWithdrawRequest',
                        'getUserHistory',
                        'getOrderHistory',
                        'userTrades',
                    ),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
                'uid' => true,
                'login' => false,
                'password' => false,
                'twofa' => false, // 2-factor authentication (one-time password key)
                'privateKey' => false, // a "0x"-prefixed hexstring private key for a wallet
                'walletAddress' => false, // the wallet address "0x"-prefixed hexstring
                'token' => false, // reserved for HTTP auth in some cases
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        // we need currency to parse market
        if ($this->currencies_by_id === null) {
            $this->fetch_currencies();
        }
        $response = $this->publicGetGetInstrumentPairs ($params);
        $markets = array();
        $results = $this->safe_value($response, 'instrumentPairs', array());
        for ($i = 0; $i < count($results); $i++) {
            $marketResult = $this->parse_market($results[$i]);
            $markets[] = $marketResult;
        }
        return $markets;
    }

    public function fetch_currencies($params = array ()) {
        $response = $this->publicGetGetInstruments ($params);
        $currencies = array();
        $results = $this->safe_value($response, 'instruments', array());
        for ($i = 0; $i < count($results); $i++) {
            $currency = $this->parse_currency($results[$i]);
            $code = $currency['code'];
            $currencies[$code] = $currency;
        }
        // we need this to parse Markets
        $this->currencies = $currencies;
        $this->currencies_by_id = $this->index_by($currencies, 'id');
        return $currencies;
    }

    public function fetch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array_merge(array(
            'pairId' => $market['id'],
            'timespan' => 1,
        ), $params);
        $response = $this->publicGetGetChart (array_merge($request, $params));
        $charts = $this->safe_value($response, 'chart', array());
        $chart = $this->safe_value($charts, 0);
        // $volume = null;
        if ($chart !== null) {
            $ticker = $this->parse_ticker($chart, $market);
            return array(
                'symbol' => $ticker['symbol'],
                'info' => $ticker['info'],
                'timestamp' => null,
                'datetime' => null,
                'high' => null,
                'low' => null,
                'bid' => null,
                'bidVolume' => null,
                'ask' => null,
                'askVolume' => null,
                'vwap' => null,
                'open' => null,
                'close' => $ticker['last'],
                'last' => $ticker['last'],
                'previousClose' => null,
                'change' => null,
                'percentage' => null,
                'average' => null,
                'baseVolume' => null,
                'quoteVolume' => null,
            );
        } else {
            return $this->parse_ticker(null, $market);
        }
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if ($this->timeframes[$timeframe] === null) {
            throw new BadRequest($this->id . ' => $timeframe ' . $timeframe . ' is not supported'); // eslint-disable-line quotes
        }
        $request = array_merge(array(
            'pairId' => $market['id'],
            'timespan' => $this->timeframes[$timeframe],
        ), $params);
        $response = $this->publicGetGetChart (array_merge($request, $params));
        $results = $this->safe_value($response, 'chart', array());
        return $this->parse_ohlcvs($results, $market, $timeframe, $since, $limit);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array_merge(array(
            'pairId' => $market['id'],
        ), $params);
        // apply $limit though does not work with API
        if ($limit !== null) {
            $request = array_merge(array( 'limit' => $limit ), $request);
        }
        $response = $this->publicGetGetOrderBook (array_merge($request, $params));
        // we need to tranform $response here as parseOrderBook - parseBidAsk does not have $market param
        if ($response !== null) {
            $orderBook = array(
                'bids' => array(),
                'asks' => array(),
            );
            $bidData = $this->safe_value($response, 'bids');
            $askData = $this->safe_value($response, 'asks');
            if ($bidData !== null) {
                for ($i = 0; $i < count($bidData); $i++) {
                    if ($bidData[$i] !== null) {
                        $price = $this->convert_from_scale($bidData[$i][0], $market['precision']['price']);
                        $amount = $this->convert_from_scale($bidData[$i][1], $market['precision']['amount']);
                        if ($price > 0 && $amount > 0) {
                            $orderBook['bids'][] = array(
                                'price' => $price,
                                'amount' => $amount,
                            );
                        }
                    }
                }
            }
            if ($askData !== null) {
                for ($i = 0; $i < count($askData); $i++) {
                    if ($askData[$i] !== null) {
                        $price = $this->convert_from_scale($askData[$i][0], $market['precision']['price']);
                        $amount = $this->convert_from_scale($askData[$i][1], $market['precision']['amount']);
                        if ($price > 0 && $amount > 0) {
                            $orderBook['asks'][] = array(
                                'price' => $price,
                                'amount' => $amount,
                            );
                        }
                    }
                }
            }
            return $this->parse_order_book($orderBook, null, 'bids', 'asks', 'price', 'amount');
        }
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array_merge(array(
            'pairId' => $market['id'],
        ), $params);
        // apply $limit though does not work with API
        if ($limit !== null) {
            $request = array_merge(array( 'limit' => $limit ), $request);
        }
        $response = $this->publicGetGetTradeHistory ($request);
        $trades = $this->safe_value($response, 'trades', array());
        return $this->parse_trades($trades, $market, $since, $limit, $params);
    }

    public function fetch_balance($params = array ()) {
        $response = $this->privatePostGetPositions ($params);
        $positions = $this->safe_value($response, 'positions', array());
        $balance = array();
        $balance['info'] = $response;
        $balance['free'] = array();
        $balance['used'] = array();
        $balance['total'] = array();
        for ($i = 0; $i < count($positions); $i++) {
            $position = $positions[$i];
            if ($position['assetType'] === 'ASSET') {
                $symbol = $position['symbol'];
                $quantity = $position['quantity'];
                $availableQuantity = $position['availableQuantity'];
                $scale = $position['quantity_scale'];
                $free = $this->convert_from_scale($availableQuantity, $scale);
                $total = $this->convert_from_scale($quantity, $scale);
                $used = floatval ($this->decimal_to_precision($total - $free, ROUND, $scale));
                if (!$this->safe_value($balance, $symbol)) {
                    $balance[$symbol] = $this->account();
                }
                $balance[$symbol]['free'] = $free;
                $balance[$symbol]['used'] = $used;
                $balance[$symbol]['total'] = $this->sum($free, $used);
            }
        }
        return $this->parse_balance($balance);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if ($type === null || $side === null || $amount === null) {
            throw new ArgumentsRequired($this->id . ' => Order does not have enough arguments');
        }
        $request = $this->create_order_request($market, $type, $side, $amount, $price, $params);
        $order = $this->privatePostOrder ($request);
        // HACK => to call twice, will not get merged by kroitor it seems
        // TODO => Remove before making a pull $request
        for ($i = 0; $i < 10; $i++) {
            try {
                $fetchedOrders = $this->fetch_orders($symbol);
                $fetchedOrderDetails = null;
                // Have to do a find because we can't use JS methods
                for ($j = 0; $j < count($fetchedOrders); $j++) {
                    if ($fetchedOrders[$j]['info']['clOrdId'] === $order['clOrdId']) {
                        $fetchedOrderDetails = $fetchedOrders[$j];
                        break;
                    }
                }
                if ($fetchedOrderDetails !== null) {
                    return $fetchedOrderDetails;
                }
            } catch (Exception $err) {
                throw new OrderNotFound('Error found while trying to access details for $order-> ', $order['clOrdId']);
            }
        }
        throw new OrderNotFound('clOrdId %o cannot be found.', $order['clOrdId']);
    }

    public function create_order_request($market, $type, $side, $amount, $price = null, $params = array ()) {
        if ($price === null) {
            $price = 0;
        }
        $amount_scale = $this->get_scale($amount);
        $price_scale = $this->get_scale($price);
        $ordType = 1;
        $requestSide = 1;
        if ($type === 'limit') {
            $ordType = 2;
        }
        if ($side === 'sell') {
            $requestSide = 2;
        }
        $request = array(
            'id' => 0,
            'instrumentId' => $market['id'],
            'symbol' => $market['symbol'],
            'side' => $requestSide,
            'ordType' => $ordType,
            'price' => $this->convert_to_scale($price, $price_scale),
            'price_scale' => $price_scale,
            'quantity' => $this->convert_to_scale($amount, $amount_scale),
            'quantity_scale' => $amount_scale,
        );
        return array_merge($request, $params);
    }

    public function create_edit_order_request($orgOrder, $market, $type, $side, $amount, $price = null, $params = array ()) {
        if ($price === null) {
            $price = 0;
        }
        $amount_scale = $this->get_scale($amount);
        $price_scale = $this->get_scale($price);
        $ordType = 1;
        $requestSide = 1;
        if ($type === 'limit') {
            $ordType = 2;
        }
        if ($side === 'sell') {
            $requestSide = 2;
        }
        $request = array(
            'id' => 0,
            'origOrderId' => $this->safe_value($orgOrder, 'info'),
            'clOrdId' => $this->safe_value($orgOrder, 'clOrdId'),
            'instrumentId' => $market['id'],
            'symbol' => $market['symbol'],
            'side' => $requestSide,
            'ordType' => $ordType,
            'price' => $this->safe_value($orgOrder, 'price'),
            'price_scale' => $this->safe_value($orgOrder, 'price_scale'),
            'quantity' => $this->safe_value($orgOrder, 'quantity'),
            'quantity_scale' => $this->safe_value($orgOrder, 'quantity_scale'),
            'price2' => $this->convert_to_scale($price, $price_scale),
            'price2_scale' => $price_scale,
            'quantity2' => $this->convert_to_scale($amount, $amount_scale),
            'quantity2_scale' => $amount_scale,
        );
        return array_merge($request, $params);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder requires a $symbol argument');
        }
        // NOTE => We need to fetch $order because we need to obtain the $symbol $id and $clientOrderId
        $order = $this->fetch_order($id, $symbol, $params);
        if ($this->safe_string($order, 'status') !== 'open') {
            throw new OrderNotFound($this->id . ' => $order $id ' . $id . ' is not found in open order');
        }
        $this->load_markets();
        $clientOrderId = $order['clientOrderId'];
        // Equos' API requires the clOrdId and clOrdId
        $request = array();
        $request['clOrdId'] = $clientOrderId;
        $request['instrumentId'] = $this->market($symbol)['id'];
        // The API gives back the wrong response without proper $id, price, etc.
        // Therefore, we just return the ID
        // It will throw an error if it is not cancellable
        $this->privatePostCancelOrder (array_merge($request, $params));
        return $id;
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request['orderId'] = $id;
        $orderHistoryResponse = $this->privatePostGetOrderHistory (array_merge($request, $params));
        $orderList = $this->safe_value($orderHistoryResponse, 'orders', array());
        try {
            $index = strlen($orderList) - 1;
            return $this->parse_order($orderList[$index], $market);
        } catch (Exception $err) {
            throw new OrderNotFound('Error found while trying to access details for order. ', $id);
        }
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['instrumentId'] = $market['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privatePostGetOrders (array_merge($request, $params));
        $orders = $this->parse_orders($this->safe_value($response, 'orders', array()), $market, $since, $limit, $params);
        return $orders;
    }

    public function fetch_all_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->fetch_orders($symbol, $since, $limit, $params);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $orders = $this->fetch_orders($symbol, $since, $limit, $params);
        $openOrders = $this->filter_by_value_since_limit($orders, 'status', 'open', $since, $limit);
        return $openOrders;
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $orders = $this->fetch_orders($symbol, $since, $limit, $params);
        $closeOrders = $this->filter_by_value_since_limit($orders, 'status', 'closed', $since, $limit);
        return $closeOrders;
    }

    public function fetch_cancelled_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $orders = $this->fetch_orders($symbol, $since, $limit, $params);
        $canceledOrders = $this->filter_by_value_since_limit($orders, 'status', 'canceled', $since, $limit);
        return $canceledOrders;
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['instrumentId'] = $market['id'];
        }
        if ($since !== null) {
            $request['timestamp'] = $since;
        }
        $response = $this->privatePostUserTrades (array_merge($request, $params));
        $result = array();
        for ($i = 0; $i < count($response['trades']); $i++) {
            $trade = $response['trades'][$i];
            $timestamp = $this->safe_integer($trade, 'time');
            // Deal with $side
            $side = $this->safe_string($trade, 'side');
            if ($side === 'BUY') {
                $side = 'buy';
            } else if ($side === 'SELL') {
                $side = 'sell';
            } else {
                $side = null;
            }
            $takerOrMaker = null;
            if ($trade['aggressorIndicator'] === true) {
                $takerOrMaker = 'taker';
            } else if (!$trade['aggressorIndicator']) {
                $takerOrMaker = 'maker';
            }
            // $price and qty may have extraneous decimal places
            $price = $this->safe_float($trade, 'price');
            $amount = $this->safe_float($trade, 'qty');
            $feeCost = $this->safe_float($trade, 'commission');
            $feeCurrency = $this->safe_float($trade, 'commCurrency');
            $result[] = array(
                'info' => $trade,
                'id' => $this->safe_string($trade, 'execId'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'symbol' => $this->safe_string($market, 'symbol'),
                'order' => $this->safe_string($trade, 'orderId'),
                'type' => null,
                'side' => $side,
                'takerOrMaker' => $takerOrMaker,
                'price' => $price,
                'amount' => $amount,
                'cost' => $amount * $price,
                'fee' => array(
                    'cost' => $feeCost,
                    'currency' => $feeCurrency,
                    'rate' => null,
                ),
            );
        }
        $result = $this->sort_by($result, 'timestamp');
        return $this->filter_by_symbol_since_limit($result, $symbol, $since, $limit);
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->get_currency_by_code($code);
        $request = array(
            'instrumentId' => $currency['id'],
        );
        $response = $this->privatePostGetDepositAddresses (array_merge($request, $params));
        $addresses = $this->safe_value($response, 'addresses', array());
        return $this->parse_deposit_address($addresses);
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->get_currency_by_code($code);
            $request['instrumentId'] = $currency['id'];
        }
        $response = $this->privatePostGetDepositHistory (array_merge($request, $params));
        $deposits = $this->safe_value($response, 'deposits', array());
        for ($i = 0; $i < count($deposits); $i++) {
            $deposit = $deposits[$i];
            $deposit['type'] = 'deposit';
        }
        return $this->parse_transactions($deposits, $currency, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->get_currency_by_code($code);
            $request['instrumentId'] = $currency['id'];
        }
        // getWithdrawRequests
        $response = $this->privatePostGetWithdrawRequests (array_merge($request, $params));
        $withdrawals = $this->safe_value($response, 'addresses', array());
        for ($i = 0; $i < count($withdrawals); $i++) {
            $deposit = $withdrawals[$i];
            $deposit['type'] = 'withdrawal';
        }
        return $this->parse_transactions($withdrawals, $currency, $since, $limit);
    }

    public function fetch_transactions($code = null, $since = null, $limit = null, $params = array ()) {
        $deposits = $this->fetch_deposits($code, $since, null, $params);
        $withdrawals = $this->fetch_withdrawals($code, $since, null, $params);
        $transactions = $this->array_concat($deposits, $withdrawals);
        // sort combined array result, latest first
        $transactions = $this->sort_by($transactions, 'timestamp', true);
        // lets apply $limit on combined array
        if ($limit !== null) {
            return $this->filter_by_since_limit($transactions, $since, $limit);
        }
        return $transactions;
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        $this->check_address($address);
        $this->load_markets();
        $currency = $this->get_currency_by_code($code);
        $scale = $this->get_scale($amount);
        $quantity = $this->convert_to_scale($amount, $scale);
        $instrumentId = $currency['id'];
        $symbol = $currency['code'];
        $request = array(
            'instrumentId' => $instrumentId,
            'symbol' => $symbol,
            'quantity' => $quantity,
            'quantity_scale' => $scale,
            'address' => $address,
        );
        // sendWithdrawRequest
        $response = $this->privatePostSendWithdrawRequest (array_merge($request, $params));
        return array(
            'info' => $response,
            'id' => null,
        );
    }

    public function fetch_trading_fees($params = array ()) {
        // getExchangeInfo
        $response = $this->publicGetGetExchangeInfo ($params);
        $tradingFees = $this->safe_value($response, 'spotFees', array());
        $taker = array();
        $maker = array();
        for ($i = 0; $i < count($tradingFees); $i++) {
            $tradingFee = $tradingFees[$i];
            if ($this->safe_string($tradingFee, 'tier') !== null) {
                $taker[$tradingFee['tier']] = $this->safe_float($tradingFee, 'taker');
                $maker[$tradingFee['tier']] = $this->safe_float($tradingFee, 'maker');
            }
        }
        return array(
            'info' => $tradingFees,
            'tierBased' => true,
            'maker' => $maker,
            'taker' => $taker,
        );
    }

    public function fetch_trading_limits($symbols = null, $params = array ()) {
        $this->load_markets();
        // getExchangeInfo
        $response = $this->publicGetGetExchangeInfo ($params);
        $tradingLimits = $this->safe_value($response, 'tradingLimits', array());
        // To-do parsing $response when available
        return array(
            'info' => $tradingLimits,
            'limits' => array(
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
        );
    }

    public function fetch_funding_limits($params = array ()) {
        // getExchangeInfo
        $response = $this->publicGetGetExchangeInfo ($params);
        $withdrawLimits = $this->safe_value($response, 'withdrawLimits', array());
        // TO-DO parse $response when available
        return array(
            'info' => $withdrawLimits,
            'withdraw' => null,
        );
    }

    public function fetch_ledger($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->get_currency_by_code($code);
            $request['instrumentId'] = $currency['id'];
        }
        $_format = array();
        $_format['format'] = 'json';
        $_format['type'] = 'position';
        $request['_format'] = $_format;
        // getUserHistory
        $response = $this->privatePostGetUserHistory (array_merge($request, $params));
        $positions = $this->safe_value($response, 'postionHistory', array());
        return $this->parse_ledger($positions, null, $since, $limit);
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function get_currency_by_code($code) {
        $currency = $this->currencies[$code];
        if ($currency === null) {
            throw new BadSymbol($this->id . ' => $code ' . $code . ' is not listed');
        }
        return $currency;
    }

    public function parse_order($order, $market = null) {
        $status = $this->parse_order_status($order);
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        } else {
            $marketId = $this->safe_string($order, 'instrumentId');
            if ($this->safe_value($this->markets_by_id, $marketId) !== null) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
            }
        }
        $timestamp = $this->parse8601($this->convert_to_iso8601_date($this->safe_string($order, 'timeStamp')));
        $lastTradeTimestamp = $timestamp;
        // Filled $price is lastPx. Should use $price instead of fillPrice
        $price = $this->convert_from_scale($this->safe_integer($order, 'price', 0), $this->safe_integer($order, 'price_scale', 0));
        $amount = $this->convert_from_scale($this->safe_integer($order, 'quantity', 0), $this->safe_integer($order, 'quantity_scale', 0));
        $filled = $this->convert_from_scale($this->safe_integer($order, 'cumQty', 0), $this->safe_integer($order, 'cumQty_scale', 0));
        $remaining = $this->convert_from_scale($this->safe_integer($order, 'leavesQty', 0), $this->safe_integer($order, 'leavesQty_scale', 0));
        $average = $this->convert_from_scale($this->safe_integer($order, 'avgPx', 0), $this->safe_integer($order, 'avgPx_scale', 0));
        $cost = $price * $filled;
        $currencyCode = null;
        $currencyId = $this->safe_integer($order, 'feeInstrumentId');
        if ($currencyId !== null) {
            $currency = $this->safe_value($this->currencies_by_id, $currencyId);
            if ($currency !== null) {
                $currencyCode = $currency['code'];
            }
        }
        $feeTotal = null;
        if ($this->safe_integer($order, 'feeTotal') !== null && $this->safe_integer($order, 'fee_scale') !== null) {
            $feeTotal = abs($this->convert_from_scale($this->safe_integer($order, 'feeTotal'), $this->safe_integer($order, 'fee_scale')));
        }
        $fee = array(                         // $fee info, if available
            'currency' => $currencyCode,        // which $currency the $fee is (usually quote)
            'cost' => $feeTotal,           // the $fee $amount in that $currency
            'rate' => null,           // the $fee rate (if available)
        );
        $id = $this->safe_string($order, 'orderId');
        $clientOrderId = $this->safe_string($order, 'clOrdId');
        $type = $this->parse_order_type($this->safe_string_lower($order, 'ordType'));
        $side = $this->parser_order_side($this->safe_string_lower($order, 'side'));
        $trades = $this->parse_trades($this->safe_value($order, 'trades', array()));
        $orderResult = array(
            'id' => $id,
            'average' => $average,
            'clientOrderId' => $clientOrderId,
            'datetime' => $this->iso8601($timestamp),
            'timestamp' => $timestamp,
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining,
            'cost' => $cost,
            'trades' => $trades,
            'fee' => $fee,
            'info' => $order,
        );
        $orderUpdateSeq = $this->safe_value($order, 'orderUpdateSeq');
        $execType = $this->safe_value($order, 'execType');
        if ($orderUpdateSeq === 0) {
            $orderResult['lastTradeTimestamp'] = null;
        } else if ($execType === 'F') {
            $orderResult['datetime'] = null;
            $orderResult['timestamp'] = null;
        } else {
            $orderResult['datetime'] = null;
            $orderResult['timestamp'] = null;
            $orderResult['lastTradeTimestamp'] = null;
        }
        if ($symbol === null) {
            $instrumentId = $this->safe_value($order, 'instrumentId');
            if (is_array($this->marketsById) && array_key_exists($instrumentId, $this->marketsById)) {
                $orderResult['symbol'] = $this->markets_by_id[$instrumentId]['symbol'];
            }
        }
        return $orderResult;
    }

    public function parse_market($market) {
        $id = $market[0]; // instrumentId
        $symbol = $market[1]; // $symbol
        $splitSymbol = explode('/', $symbol);
        $base = strtolower($splitSymbol[0]);
        $quote = strtolower($splitSymbol[1]);
        $baseId = $market[3]; // $baseId
        $quoteId = $market[2]; // quotedId
        $baseCurrency = $this->safe_value($this->currencies_by_id, $baseId);
        $quoteCurrency = $this->safe_value($this->currencies_by_id, $quoteId);
        if ($baseCurrency !== null) {
            $base = $baseCurrency['code'];
        }
        if ($quoteCurrency !== null) {
            $quote = $quoteCurrency['code'];
        }
        // status
        $active = false;
        if ($market[6] === 1) {
            $active = true;
        }
        $precision = array(
            'amount' => $market[5], // quantity_scale
            'price' => $market[4], // price_scale
            'cost' => null,
        );
        $limits = array(
            'amount' => array(
                'min' => null,
                'max' => null,
            ),
            'price' => array(
                'min' => null,
                'max' => null,
            ),
            'cost' => array(
                'min' => null,
                'max' => null,
            ),
        );
        return array(
            'id' => $id,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'active' => $active,
            'precision' => $precision,
            'limits' => $limits,
            'info' => $market,
        );
    }

    public function parse_currency($currency) {
        $id = $currency[0]; // instrumentId
        $code = $currency[1]; // symbol
        $name = $currency[6]; // $name
        $active = false;
        // status
        if ($currency[4] === 1) {
            $active = true;
        }
        // $fee = $currency[5]; // withdraw_fee
        // HACK => Fee is 0 during promotional periods
        // However, it is currently a percentage and the absolute
        // amount has to be updated in the API side
        $fee = null;
        // HACK => Precision is 6, as shown on the exchange.
        // May need more updates if this changes
        // $precision = $currency[2]; // price_scale
        $precision = $this->safe_integer($currency, 3);
        $limits = array(
            'amount' => array(
                'min' => null,
                'max' => null,
            ),
            'price' => array(
                'min' => null,
                'max' => null,
            ),
            'cost' => array(
                'min' => null,
                'max' => null,
            ),
            'withdraw' => array(
                'min' => null,
                'max' => null,
            ),
        );
        return array(
            'id' => $id,
            'code' => $code,
            'name' => $name,
            'active' => $active,
            'precision' => $precision,
            'limits' => $limits,
            'fee' => $fee,
            'info' => $currency,
        );
    }

    public function parse_ticker($ticker, $market = null) {
        $timestamp = null;
        $datetime = null;
        $open = null;
        $high = null;
        $low = null;
        $close = null;
        // $volume = null;
        if ($ticker !== null) {
            $timestamp = $ticker[0];
            $datetime = $this->iso8601($timestamp);
            $open = $this->convert_from_scale($ticker[1], $market['precision']['price']);
            $high = $this->convert_from_scale($ticker[2], $market['precision']['price']);
            $low = $this->convert_from_scale($ticker[3], $market['precision']['price']);
            $close = $this->convert_from_scale($ticker[4], $market['precision']['price']);
            // $volume = $this->convert_to_scale(chart[5], $market['precision']['amount'])
        }
        return array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'bid' => null,
            'ask' => null,
            'last' => $close,
            'high' => $high,
            'low' => $low,
            'bidVolume' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $close,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => null,
            'quoteVolume' => null,
            'info' => $ticker,
        );
    }

    public function parse_ohlcv($ohlcv, $market = null, $timeframe = '1m', $since = null, $limit = null) {
        $timestamp = $ohlcv[0];
        $open = $this->convert_from_scale($ohlcv[1], $market['precision']['price']);
        $high = $this->convert_from_scale($ohlcv[2], $market['precision']['price']);
        $low = $this->convert_from_scale($ohlcv[3], $market['precision']['price']);
        $close = $this->convert_from_scale($ohlcv[4], $market['precision']['price']);
        $volume = $this->convert_from_scale($ohlcv[5], $market['precision']['amount']);
        // $volume = $ohlcv[5];
        return [$timestamp, $open, $high, $low, $close, $volume];
    }

    public function parse_trade($trade, $market) {
        $price = $this->convert_from_scale($this->safe_integer($trade, 0), $market['precision']['price']);
        $amount = $this->convert_from_scale($this->safe_integer($trade, 1), $market['precision']['amount']);
        $date = $this->convert_to_iso8601_date($this->safe_string($trade, 2));
        $timestamp = $this->parse8601($date);
        $dateTime = $this->iso8601($timestamp);
        $seqNumber = $this->safe_string($trade, 3);
        return array(
            'info' => array( 'trade' => $trade ),                    // the original decoded JSON as is
            'id' => $seqNumber,  // string $trade id
            'timestamp' => $timestamp,              // Unix $timestamp in milliseconds
            'datetime' => $dateTime,  // ISO8601 datetime with milliseconds
            'symbol' => $market['symbol'],                  // symbol
            'order' => null,  // string order id or null/None/null
            'type' => null,                    // order type, 'market', 'limit' or null/None/null
            'side' => null,                      // direction of the $trade, 'buy' or 'sell'
            'takerOrMaker' => null,                    // string, 'taker' or 'maker'
            'price' => $price,                 // float $price in quote currency
            'amount' => $amount,                        // $amount of base currency
            'cost' => null,                 // total cost (including fees), `$price * $amount`
            'fee' => array(                           // provided by exchange or calculated by ccxt
                'cost' => null,                        // float
                'currency' => null,                      // usually base currency for buys, quote currency for sells
                'rate' => null,                          // the fee rate (if available)
            ),
        );
    }

    public function is_open_order($order) {
        $conditionOne = false;
        $conditionTwo = false;
        $execType = $this->safe_value($order, 'execType');
        $leavesQty = $this->safe_value($order, 'leavesQty');
        $ordType = $this->safe_value($order, 'ordType');
        $ordStatus = $this->safe_value($order, 'ordStatus');
        if ($execType === 'F' && $leavesQty !== 0 && $ordType !== '1') {
            $conditionOne = true;
        }
        if ($execType !== 'F' && $execType !== '4' && $execType !== '8' && $execType !== 'B' && $execType !== 'C' && $ordType !== '1') {
            $conditionTwo = true;
        }
        if (($conditionOne || $conditionTwo) && $ordStatus !== '8') {
            return true;
        } else {
            return false;
        }
    }

    public function is_closed_order($order) {
        $conditionOne = false;
        $conditionTwo = false;
        $execType = $this->safe_value($order, 'execType');
        $ordType = $this->safe_value($order, 'ordType');
        $ordStatus = $this->safe_value($order, 'ordStatus');
        $cumQty = $this->safe_value($order, 'cumQty');
        if ($execType !== '4' && $execType !== '8' && $ordStatus !== '8' && $ordType === '1') {
            $conditionOne = true;
        }
        if ($execType === 'F' || $execType === 'B' || $execType === 'C') {
            $conditionTwo = true;
        }
        if ($conditionOne || ($conditionTwo && $cumQty !== 0)) {
            return true;
        } else {
            return false;
        }
    }

    public function is_cancelled_order($order) {
        $conditionOne = false;
        $conditionTwo = false;
        $execType = $this->safe_value($order, 'execType');
        $ordStatus = $this->safe_value($order, 'ordStatus');
        $cumQty = $this->safe_value($order, 'cumQty');
        if ($execType === '4' || $execType === '8' || $ordStatus === '8') {
            $conditionOne = true;
        }
        if (($execType === 'B' || $execType === 'C') && $cumQty === 0) {
            $conditionTwo = true;
        }
        if ($conditionOne || $conditionTwo) {
            return true;
        } else {
            return false;
        }
    }

    public function parse_order_status($order) {
        if ($this->is_open_order($order)) {
            return 'open';
        } else if ($this->is_closed_order($order)) {
            return 'closed';
        } else if ($this->is_cancelled_order($order)) {
            return 'canceled';
        } else {
            return null;
        }
        // $statuses = array(
        //     '0' => 'open',
        //     '1' => 'partially filled',
        //     '2' => 'filled',
        //     '3' => 'done for day',
        //     '4' => 'cancelled',
        //     '5' => 'replaced',
        //     '6' => 'pending cancel',
        //     '7' => 'stopped',
        //     '8' => 'rejected',
        //     '9' => 'suspended',
        //     'A' => 'pending New',
        //     'B' => 'calculated',
        //     'C' => 'expired',
        //     'D' => ' accepted for bidding',
        //     'E' => 'pending Replace',
        //     'F' => 'trade', // (partial fill or fill)
        // );
        // return $this->safe_string($statuses, status, status);
    }

    public function parser_order_side($side) {
        $sides = array(
            '1' => 'buy',
            '2' => 'sell',
        );
        return $this->safe_string($sides, $side, $side);
    }

    public function parse_order_type($type) {
        $types = array(
            '1' => 'market',
            '2' => 'limit',
            '3' => 'stop',
            '4' => 'stop limit',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_deposit_address($addresses) {
        $address = array(
            'currency' => null, // currency code
            'address' => null,   // $address in terms of requested currency
            'tag' => null,           // tag / memo / paymentId for particular currencies (XRP, XMR, ...)
            'info' => null,     // raw unparsed data as returned from the exchange
        );
        $addressesLength = is_array($addresses) ? count($addresses) : 0;
        if ($addresses && $addressesLength > 0) {
            $address['currency'] = $this->safe_string($addresses[0], 'symbol');
            $address['address'] = $this->safe_string($addresses[0], 'address');
            $address['info'] = $addresses[0];
        }
        return $address;
    }

    public function parse_transaction($transaction, $currency = null) {
        $id = $this->safe_string($transaction, 'id');
        $txid = $this->safe_string($transaction, 'transactionId');
        $datetime = $this->convert_to_iso8601_date($this->safe_string($transaction, 'timestamp', ' '));
        $timestamp = $this->parse8601($datetime);
        $address = $this->safe_string($transaction, 'address');
        $type = $this->safe_string($transaction, 'type');
        $amount = $this->safe_float($transaction, 'balance_change');
        $code = $this->safe_string($transaction, 'symbol');
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'status'));
        return array(
            'info' => $transaction,    // the JSON response from the exchange as is
            'id' => $id,    // exchange-specific $transaction $id, string
            'txid' => $txid,
            'timestamp' => $timestamp,             // $timestamp in milliseconds
            'datetime' => $datetime, // ISO8601 string of the $timestamp
            'addressFrom' => null, // sender
            'address' => $address, // "from" or "to"
            'addressTo' => null, // receiver
            'tagFrom' => null, // "tag" or "memo" or "payment_id" associated with the sender
            'tag' => null, // "tag" or "memo" or "payment_id" associated with the $address
            'tagTo' => null, // "tag" or "memo" or "payment_id" associated with the receiver
            'type' => $type,   // or 'withdrawal', string
            'amount' => $amount,     // float (does not include the fee)
            'currency' => $code,       // a common unified $currency $code, string
            'status' => $status,   // 'ok', 'failed', 'canceled', string
            'updated' => null,  // UTC $timestamp of most recent $status change in ms
            'comment' => null,
            'fee' => array(                 // the entire fee structure may be null
                'currency' => null,   // a unified fee $currency $code
                'cost' => null,      // float
                'rate' => null,   // approximately, fee['cost'] / $amount, float
            ),
        );
    }

    public function parse_ledger_entry($entry, $currency = null) {
        $id = $this->safe_string($entry, 'reportid');
        $currencyId = $this->safe_integer($entry, 'instrumentId1');
        $referenceId = $this->safe_string($entry, 'transactionid');
        $timestamp = $this->safe_integer($entry, 'publishtime');
        $txnType = $this->safe_string($entry, 'txnType');
        $execId = $this->safe_integer($entry, 'execId');
        $orderId = $this->safe_integer($entry, 'orderId');
        $type = $this->parse_ledger_entry_type($txnType, $execId, $orderId);
        $currencyCode = null;
        $direction = null;
        $amount = 0;
        $before = 0;
        $after = 0;
        if ($currencyId !== null) {
            $currency = $this->currencies_by_id[$currencyId];
            if ($currency !== null) {
                $currencyCode = $currency['code'];
                $amount = $this->convert_from_scale($this->safe_integer($entry, 'change1', 0), $currency['precision']);
                $after = $this->convert_from_scale($this->safe_integer($entry, 'qty1', 0), $currency['precision']);
            }
            $before = $after - $amount;
            if ($amount < 0) {
                $direction = 'out';
                $amount = -$amount;
            } else {
                $direction = 'in';
            }
        }
        return array(
            'id' => $id,
            'direction' => $direction,
            'account' => null,
            'referenceId' => $referenceId,
            'referenceAccount' => null,
            'type' => $type,
            'currency' => $currencyCode,
            'amount' => $amount,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'before' => $before,
            'after' => $after,
            'status' => 'ok',
            'fee' => null,
            'info' => $entry,
        );
    }

    public function parse_ledger_entry_type($type, $execId, $orderId) {
        if (($execId > 0 && $orderId > 0) || $type === '4019') {
            return 'trade';
        }
        $types = array(
            '4011' => 'deposit', // TX_DEPOSIT
            '4012' => 'withdraw', // TX_WITHDRAW
            '4013' => 'deposit', // TX_ADMIN_DEPOSIT
            '4014' => 'withdraw', // TX_ADMIN_WITHDRAW
            '4015' => 'fee', // TX_FEE
            '4016' => 'transaction', // TX_ADJUSTMENT
            '4017' => 'transaction', // TX_INVEST_FUND
            '4018' => 'transaction', // TX_DIVEST_FUND
            '4019' => 'transaction', // TX_TRADE_FILL
            '4020' => 'transaction', // TX_FUNDING_RATE
            '4021' => 'transaction', // TX_RESTAT
            '4022' => 'transaction', // TX_COLLATERAL_SWAP
            '4023' => 'transaction', // TX_COLLATRAL_SWAP_ADJ
            '4024' => 'transaction', // TX_ADMIN_WITHDRAW_REJECTED
            '4025' => 'transaction', // TX_FROM_BANKRUPT_REMAINDER
            '4026' => 'transaction', // TX_TO_BANKRUPT_REMAINDER
            '4027' => 'transaction', // TX_BALANCE_ADMIN_INVALID_USER_REJECTED
            '4028' => 'transaction', // TX_EXPIRE_SETTLED
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_orders($orders, $market = null, $since = null, $limit = null, $params = array ()) {
        // For every time in $orders, parse $order, and extend.
        $result = array();
        for ($i = 0; $i < count($orders); $i++) {
            $order = array_merge($this->parse_order($orders[$i], $market), $params);
            $result[] = $order;
        }
        // $result = is_array($orders).map (($order) => array_merge($this->parse_order($order, $market), $params)) ? array_values($orders).map (($order) => array_merge($this->parse_order($order, $market), $params)) : array();
        // Use id to sort, timestamp is not guaranteed
        // HOWEVER. id is a string and not a number
        // So I need to convert back and forth
        for ($i = 0; $i < count($result); $i++) {
            $result[$i]['id'] = $this->safe_integer($result[$i], 'id');
        }
        $result = $this->sort_by($result, 'id');
        for ($i = 0; $i < count($result); $i++) {
            $result[$i]['id'] = $this->safe_string($result[$i], 'id');
        }
        $symbol = ($market !== null) ? $market['symbol'] : null;
        $filtered = $this->filter_by_symbol_since_limit($result, $symbol, $since, $limit);
        return $filtered;
    }

    public function parse_transaction_status($status) {
        return $status;
    }

    public function convert_to_iso8601_date($dateString) {
        if ($dateString !== null) {
            // '20200328-10:31:01.575' -> '2020-03-28 12:42:48.000'
            $splits = explode('-', $dateString);
            $partOne = $this->safe_string($splits, 0);
            $PartTwo = $this->safe_string($splits, 1);
            if ($partOne === null || $PartTwo === null) {
                return null;
            }
            if (strlen($partOne) !== 8) {
                return null;
            }
            $date = mb_substr($partOne, 0, 4 - 0) . '-' . mb_substr($partOne, 4, 6 - 4) . '-' . mb_substr($partOne, 6, 8 - 6);
            $datetime = $date . ' ' . $PartTwo;
            return $datetime;
        } else {
            return '';
        }
    }

    public function convert_from_scale($number, $scale) {
        return $this->from_wei($number, $scale);
    }

    public function get_scale($num) {
        $s = $this->number_to_string($num);
        return $this->precision_from_string($s);
    }

    public function convert_to_scale($number, $scale) {
        return intval ($this->to_wei($number, $scale));
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $query = $path;
        if ($method === 'GET') {
            if ($params) {
                $query .= '?' . $this->urlencode($params);
            }
        } else if ($method === 'POST') {
            $format = $this->safe_value($params, '_format');
            if ($format !== null) {
                $query .= '?' . $this->urlencode($format);
                $params = $this->omit($params, '_format');
            }
            $headers = array(
                'Content-Type' => 'application/json',
            );
            $params['nonce'] = $this->nonce();
            if ($api === 'private') {
                $this->check_required_credentials();
                $headers['requestToken'] = $this->apiKey;
                $params['userId'] = $this->uid;
                $body = $this->json($params);
                $signature = $this->hmac($this->encode($body), $this->encode($this->secret), 'sha384');
                $headers['signature'] = $signature;
            }
            if ($body === null) {
                $body = $this->json($params);
            }
        }
        $url = $this->urls['api'][$api] . $query;
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
